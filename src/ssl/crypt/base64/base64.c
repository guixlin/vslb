/*
 *  RFC 1521 base64 encoding/decoding
 */

#ifndef _CRT_SECURE_NO_DEPRECATE
#define _CRT_SECURE_NO_DEPRECATE 1
#endif

#include "base64.h"

static const int base64_enc_map[64] =
{
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
    'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
    'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',
    'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
    'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',
    'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', '+', '/'
};

static const int base64_dec_map[128] =
{
    127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
    127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
    127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
    127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
    127, 127, 127,  62, 127, 127, 127,  63,  52,  53,
     54,  55,  56,  57,  58,  59,  60,  61, 127, 127,
    127,  64, 127, 127, 127,   0,   1,   2,   3,   4,
      5,   6,   7,   8,   9,  10,  11,  12,  13,  14,
     15,  16,  17,  18,  19,  20,  21,  22,  23,  24,
     25, 127, 127, 127, 127, 127, 127,  26,  27,  28,
     29,  30,  31,  32,  33,  34,  35,  36,  37,  38,
     39,  40,  41,  42,  43,  44,  45,  46,  47,  48,
     49,  50,  51, 127, 127, 127, 127, 127
};

static __inline void 
base64_transfer(unsigned char **src, unsigned char **dst)
{
	int C1, C2, C3;

	C1 = *(*src)++;
	C2 = *(*src)++;
	C3 = *(*src)++;

	*(*dst)++ = base64_enc_map[(C1 >> 2) & 0x3F];
	*(*dst)++ = base64_enc_map[(((C1 &  3) << 4) + (C2 >> 4)) & 0x3F];
	*(*dst)++ = base64_enc_map[(((C2 & 15) << 2) + (C3 >> 6)) & 0x3F];
	*(*dst)++ = base64_enc_map[C3 & 0x3F];
}

/*
 * Encode a buffer into base64 format
 */
int
base64_encode(unsigned char *dst, int *dlen,
              unsigned char *src, int  slen, int flag)
{
	int i, n;
	int C1, C2;
	unsigned char *p;
	int	counter = 0;

	if (slen == 0)
		return 0;

	n = (slen << 3)/6;

	switch ((slen << 3) - (n * 6)) {
        case  2:
        	n += 3;
        	break;
        case  4:
        	n += 2;
        	break;
        default:
        	break;
	}

	if (*dlen < n + 1) {
		*dlen = n + 1;
		return ERR_BASE64_BUFFER_TOO_SMALL;
	}

	n = (slen / 3) * 3;

	if(flag) {
		for (i = 0, p = dst; i < n; i += 3) {
			base64_transfer(&src, &p);
			counter += 4;
			if((counter%64 == 0) && (i+3 < n)) {
				*p++ = ';';
			}
		}
	} else {
		for (i = 0, p = dst; i < n; i += 3) {
			base64_transfer(&src, &p);
		}
	}

	if (i < slen) {
		C1 = *src++;
		C2 = ((i + 1) < slen) ? *src++ : 0;

		*p++ = base64_enc_map[(C1 >> 2) & 0x3F];
		*p++ = base64_enc_map[(((C1 & 3) << 4) + (C2 >> 4)) & 0x3F];
		*p++ = ((i + 1) < slen) ?
			base64_enc_map[(((C2 & 15) << 2)) & 0x3F] : '=';

		*p++ = '=';
	}

	*dlen = p - dst;

	return *p = 0;
}


/*
 * Decode a base64-formatted buffer
 */
int base64_decode(unsigned char *dst, int *dlen,
                  unsigned char *src, int  slen)
{
	int i, j, n;
	unsigned long x;
	unsigned char *p;

	for (i = j = n = 0; i < slen; i++) {
		if ((slen - i ) >= 2 &&
		    src[i] == '\r' && src[i + 1] == '\n') {
			continue;
		}

		if (src[i] == '\n') {
			continue;
		}

		if (src[i] == '=' && ++j > 2) {
			return ERR_BASE64_INVALID_CHARACTER;
		}

		if (src[i] > 127 || base64_dec_map[src[i]] == 127) {
			return ERR_BASE64_INVALID_CHARACTER;
		}

		if (base64_dec_map[src[i]] < 64 && j != 0) {
			return ERR_BASE64_INVALID_CHARACTER;
		}

		n++;
	}

	if (n == 0) {
		return 0;
	}

	n = ((n * 6) + 7) >> 3;

	if (*dlen < n) {
		*dlen = n;
		return ERR_BASE64_BUFFER_TOO_SMALL;
	}

	for (j = 3, n = x = 0, p = dst; i > 0; i--, src++) {
		if (*src == '\r' || *src == '\n') {
			continue;
		}

		j -= (base64_dec_map[*src] == 64);
		x  = (x << 6) | (base64_dec_map[*src] & 0x3F);

		if (++n == 4) {
			n = 0;
			*p++ = (unsigned char)(x >> 16);
			if (j > 1) {
				*p++ = (unsigned char)(x >> 8);
			}

			if (j > 2) {
				*p++ = (unsigned char)x;
			}
		}
	}
	*dlen = p - dst;
    
	return 0;
}

static const char _base64_src[] = "_base64_src";

#if defined(SELF_TEST)

#include <string.h>
#include <stdio.h>

static const unsigned char base64_test_dec[64] =
{
    0x24, 0x48, 0x6E, 0x56, 0x87, 0x62, 0x5A, 0xBD,
    0xBF, 0x17, 0xD9, 0xA2, 0xC4, 0x17, 0x1A, 0x01,
    0x94, 0xED, 0x8F, 0x1E, 0x11, 0xB3, 0xD7, 0x09,
    0x0C, 0xB6, 0xE9, 0x10, 0x6F, 0x22, 0xEE, 0x13,
    0xCA, 0xB3, 0x07, 0x05, 0x76, 0xC9, 0xFA, 0x31,
    0x6C, 0x08, 0x34, 0xFF, 0x8D, 0xC2, 0x6C, 0x38,
    0x00, 0x43, 0xE9, 0x54, 0x97, 0xAF, 0x50, 0x4B,
    0xD1, 0x41, 0xBA, 0x95, 0x31, 0x5A, 0x0B, 0x97
};

static const unsigned char base64_test_enc[] =
    "JEhuVodiWr2/F9mixBcaAZTtjx4Rs9cJDLbpEG8i7hPK"
    "swcFdsn6MWwINP+Nwmw4AEPpVJevUEvRQbqVMVoLlw==";

#ifdef WITH_MAIN_FUNC
static const unsigned char pem_enc[] =
	"MIIDvTCCAyagAwIBAgIBADANBgkqhkiG9w0BAQQFADCBoTELMAkGA1UEBhMCQ04x"
	"EDAOBgNVBAgTB0JlaWppbmcxEDAOBgNVBAcTB0JlaWppbmcxFjAUBgNVBAoTDUFy"
	"cmF5bmV0d29ya3MxCzAJBgNVBAsTAlFBMR8wHQYDVQQDExZUUUEgQ2VydGlmaWNh"
	"dGUgQ2VudGVyMSgwJgYJKoZIhvcNAQkBFhlndW95dWFuQGFycmF5bmV0d29ya3Mu"
	"bmV0MB4XDTA2MTEwODAzMDMxNloXDTE2MTEwNTAzMDMxNlowgaExCzAJBgNVBAYT"
	"AkNOMRAwDgYDVQQIEwdCZWlqaW5nMRAwDgYDVQQHEwdCZWlqaW5nMRYwFAYDVQQK"
	"Ew1BcnJheW5ldHdvcmtzMQswCQYDVQQLEwJRQTEfMB0GA1UEAxMWVFFBIENlcnRp"
	"ZmljYXRlIENlbnRlcjEoMCYGCSqGSIb3DQEJARYZZ3VveXVhbkBhcnJheW5ldHdv"
	"cmtzLm5ldDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAqt7TyXvyvY1Jhw/9"
	"dcU0uEud9+aMAU6sscCo34mw1dq+6GzQchvWQTGs6fz8s4QHXsxMb8BJs0QBADI3"
	"mALbAn4PvugUnaC+mUQhZ6MFEXL0qyxv/TDbFUPmMPi+cONCVCBXNIWagiaX37L7"
	"sxsHw6r4WPoeBZDXYMgj7Oci8TkCAwEAAaOCAQEwgf4wHQYDVR0OBBYEFI9cdozl"
	"0blgVdajRJC6AhhoZALvMIHOBgNVHSMEgcYwgcOAFI9cdozl0blgVdajRJC6Ahho"
	"ZALvoYGnpIGkMIGhMQswCQYDVQQGEwJDTjEQMA4GA1UECBMHQmVpamluZzEQMA4G"
	"A1UEBxMHQmVpamluZzEWMBQGA1UEChMNQXJyYXluZXR3b3JrczELMAkGA1UECxMC"
	"UUExHzAdBgNVBAMTFlRRQSBDZXJ0aWZpY2F0ZSBDZW50ZXIxKDAmBgkqhkiG9w0B"
	"CQEWGWd1b3l1YW5AYXJyYXluZXR3b3Jrcy5uZXSCAQAwDAYDVR0TBAUwAwEB/zAN"
	"BgkqhkiG9w0BAQQFAAOBgQCKhOkx05JOo4BnR+T1SeLw9y18S7eVJv5E8NV0kr0l"
	"sKalNfU32rm5loGAd6SKLapteQTxHxec+bSBVT5NqieFh4P3oYMXugduYJkIw+3I"
	"3iQZ2yxdgDCxg69+6vg5xo71jotAGv0ft3qkA/mogchHXHbO/pFofVBn5t6c2zV/"
	"hQ==";

static const unsigned char pem_dec[] =
{
	0x30, 0x82, 0x03, 0xbd, 0x30, 0x82, 0x03, 0x26, 0xa0, 0x03, 0x02,
	0x01, 0x02, 0x02, 0x01, 0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86,
	0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x04, 0x05, 0x00, 0x30, 0x81,
	0xa1, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,
	0x02, 0x43, 0x4e, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04,
	0x08, 0x13, 0x07, 0x42, 0x65, 0x69, 0x6a, 0x69, 0x6e, 0x67, 0x31,
	0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x07, 0x42,
	0x65, 0x69, 0x6a, 0x69, 0x6e, 0x67, 0x31, 0x16, 0x30, 0x14, 0x06,
	0x03, 0x55, 0x04, 0x0a, 0x13, 0x0d, 0x41, 0x72, 0x72, 0x61, 0x79,
	0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x31, 0x0b, 0x30,
	0x09, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x02, 0x51, 0x41, 0x31,
	0x1f, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x16, 0x54,
	0x51, 0x41, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63,
	0x61, 0x74, 0x65, 0x20, 0x43, 0x65, 0x6e, 0x74, 0x65, 0x72, 0x31,
	0x28, 0x30, 0x26, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,
	0x01, 0x09, 0x01, 0x16, 0x19, 0x67, 0x75, 0x6f, 0x79, 0x75, 0x61,
	0x6e, 0x40, 0x61, 0x72, 0x72, 0x61, 0x79, 0x6e, 0x65, 0x74, 0x77,
	0x6f, 0x72, 0x6b, 0x73, 0x2e, 0x6e, 0x65, 0x74, 0x30, 0x1e, 0x17,
	0x0d, 0x30, 0x36, 0x31, 0x31, 0x30, 0x38, 0x30, 0x33, 0x30, 0x33,
	0x31, 0x36, 0x5a, 0x17, 0x0d, 0x31, 0x36, 0x31, 0x31, 0x30, 0x35,
	0x30, 0x33, 0x30, 0x33, 0x31, 0x36, 0x5a, 0x30, 0x81, 0xa1, 0x31,
	0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43,
	0x4e, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,
	0x07, 0x42, 0x65, 0x69, 0x6a, 0x69, 0x6e, 0x67, 0x31, 0x10, 0x30,
	0x0e, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x07, 0x42, 0x65, 0x69,
	0x6a, 0x69, 0x6e, 0x67, 0x31, 0x16, 0x30, 0x14, 0x06, 0x03, 0x55,
	0x04, 0x0a, 0x13, 0x0d, 0x41, 0x72, 0x72, 0x61, 0x79, 0x6e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x31, 0x0b, 0x30, 0x09, 0x06,
	0x03, 0x55, 0x04, 0x0b, 0x13, 0x02, 0x51, 0x41, 0x31, 0x1f, 0x30,
	0x1d, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x16, 0x54, 0x51, 0x41,
	0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74,
	0x65, 0x20, 0x43, 0x65, 0x6e, 0x74, 0x65, 0x72, 0x31, 0x28, 0x30,
	0x26, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09,
	0x01, 0x16, 0x19, 0x67, 0x75, 0x6f, 0x79, 0x75, 0x61, 0x6e, 0x40,
	0x61, 0x72, 0x72, 0x61, 0x79, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72,
	0x6b, 0x73, 0x2e, 0x6e, 0x65, 0x74, 0x30, 0x81, 0x9f, 0x30, 0x0d,
	0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01,
	0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81,
	0x81, 0x00, 0xaa, 0xde, 0xd3, 0xc9, 0x7b, 0xf2, 0xbd, 0x8d, 0x49,
	0x87, 0x0f, 0xfd, 0x75, 0xc5, 0x34, 0xb8, 0x4b, 0x9d, 0xf7, 0xe6,
	0x8c, 0x01, 0x4e, 0xac, 0xb1, 0xc0, 0xa8, 0xdf, 0x89, 0xb0, 0xd5,
	0xda, 0xbe, 0xe8, 0x6c, 0xd0, 0x72, 0x1b, 0xd6, 0x41, 0x31, 0xac,
	0xe9, 0xfc, 0xfc, 0xb3, 0x84, 0x07, 0x5e, 0xcc, 0x4c, 0x6f, 0xc0,
	0x49, 0xb3, 0x44, 0x01, 0x00, 0x32, 0x37, 0x98, 0x02, 0xdb, 0x02,
	0x7e, 0x0f, 0xbe, 0xe8, 0x14, 0x9d, 0xa0, 0xbe, 0x99, 0x44, 0x21,
	0x67, 0xa3, 0x05, 0x11, 0x72, 0xf4, 0xab, 0x2c, 0x6f, 0xfd, 0x30,
	0xdb, 0x15, 0x43, 0xe6, 0x30, 0xf8, 0xbe, 0x70, 0xe3, 0x42, 0x54,
	0x20, 0x57, 0x34, 0x85, 0x9a, 0x82, 0x26, 0x97, 0xdf, 0xb2, 0xfb,
	0xb3, 0x1b, 0x07, 0xc3, 0xaa, 0xf8, 0x58, 0xfa, 0x1e, 0x05, 0x90,
	0xd7, 0x60, 0xc8, 0x23, 0xec, 0xe7, 0x22, 0xf1, 0x39, 0x02, 0x03,
	0x01, 0x00, 0x01, 0xa3, 0x82, 0x01, 0x01, 0x30, 0x81, 0xfe, 0x30,
	0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x8f,
	0x5c, 0x76, 0x8c, 0xe5, 0xd1, 0xb9, 0x60, 0x55, 0xd6, 0xa3, 0x44,
	0x90, 0xba, 0x02, 0x18, 0x68, 0x64, 0x02, 0xef, 0x30, 0x81, 0xce,
	0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x81, 0xc6, 0x30, 0x81, 0xc3,
	0x80, 0x14, 0x8f, 0x5c, 0x76, 0x8c, 0xe5, 0xd1, 0xb9, 0x60, 0x55,
	0xd6, 0xa3, 0x44, 0x90, 0xba, 0x02, 0x18, 0x68, 0x64, 0x02, 0xef,
	0xa1, 0x81, 0xa7, 0xa4, 0x81, 0xa4, 0x30, 0x81, 0xa1, 0x31, 0x0b,
	0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43, 0x4e,
	0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x07,
	0x42, 0x65, 0x69, 0x6a, 0x69, 0x6e, 0x67, 0x31, 0x10, 0x30, 0x0e,
	0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x07, 0x42, 0x65, 0x69, 0x6a,
	0x69, 0x6e, 0x67, 0x31, 0x16, 0x30, 0x14, 0x06, 0x03, 0x55, 0x04,
	0x0a, 0x13, 0x0d, 0x41, 0x72, 0x72, 0x61, 0x79, 0x6e, 0x65, 0x74,
	0x77, 0x6f, 0x72, 0x6b, 0x73, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03,
	0x55, 0x04, 0x0b, 0x13, 0x02, 0x51, 0x41, 0x31, 0x1f, 0x30, 0x1d,
	0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x16, 0x54, 0x51, 0x41, 0x20,
	0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65,
	0x20, 0x43, 0x65, 0x6e, 0x74, 0x65, 0x72, 0x31, 0x28, 0x30, 0x26,
	0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x01,
	0x16, 0x19, 0x67, 0x75, 0x6f, 0x79, 0x75, 0x61, 0x6e, 0x40, 0x61,
	0x72, 0x72, 0x61, 0x79, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
	0x73, 0x2e, 0x6e, 0x65, 0x74, 0x82, 0x01, 0x00, 0x30, 0x0c, 0x06,
	0x03, 0x55, 0x1d, 0x13, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff,
	0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,
	0x01, 0x04, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00, 0x8a, 0x84, 0xe9,
	0x31, 0xd3, 0x92, 0x4e, 0xa3, 0x80, 0x67, 0x47, 0xe4, 0xf5, 0x49,
	0xe2, 0xf0, 0xf7, 0x2d, 0x7c, 0x4b, 0xb7, 0x95, 0x26, 0xfe, 0x44,
	0xf0, 0xd5, 0x74, 0x92, 0xbd, 0x25, 0xb0, 0xa6, 0xa5, 0x35, 0xf5,
	0x37, 0xda, 0xb9, 0xb9, 0x96, 0x81, 0x80, 0x77, 0xa4, 0x8a, 0x2d,
	0xaa, 0x6d, 0x79, 0x04, 0xf1, 0x1f, 0x17, 0x9c, 0xf9, 0xb4, 0x81,
	0x55, 0x3e, 0x4d, 0xaa, 0x27, 0x85, 0x87, 0x83, 0xf7, 0xa1, 0x83,
	0x17, 0xba, 0x07, 0x6e, 0x60, 0x99, 0x08, 0xc3, 0xed, 0xc8, 0xde,
	0x24, 0x19, 0xdb, 0x2c, 0x5d, 0x80, 0x30, 0xb1, 0x83, 0xaf, 0x7e,
	0xea, 0xf8, 0x39, 0xc6, 0x8e, 0xf5, 0x8e, 0x8b, 0x40, 0x1a, 0xfd,
	0x1f, 0xb7, 0x7a, 0xa4, 0x03, 0xf9, 0xa8, 0x81, 0xc8, 0x47, 0x5c,
	0x76, 0xce, 0xfe, 0x91, 0x68, 0x7d, 0x50, 0x67, 0xe6, 0xde, 0x9c,
	0xdb, 0x35, 0x7f, 0x85
};
#endif /* WITH_MAIN_FUNC */

/*
 * selftest routine
 */
static int
base64_self_test(int verbose)
{
	int len;
	int i;
	unsigned char *src, buffer[128];
#ifdef WITH_MAIN_FUNC
	unsigned char der[2048];
#endif

	if (verbose != 0) {
		printf("  Base64 encoding test: ");
	}

	len = sizeof(buffer);
	src = (unsigned char *)base64_test_dec;
	if (base64_encode( buffer, &len, src, 64, 0) != 0 ||
	    memcmp(base64_test_enc,  buffer, 88) != 0) {
		if (verbose != 0) {
			printf("failed\n");
		}

		return 1;
	}

	if (verbose != 0) {
		printf("passed\n  Base64 decoding test: ");
	}

	len = sizeof(buffer);
	src = (unsigned char *)base64_test_enc;

	if (base64_decode(buffer, &len, src, 88) != 0 ||
	    memcmp(base64_test_dec, buffer, 64) != 0) {
		if (verbose != 0) {
			printf("failed\n");
		}

		return 1;
	}

#ifdef WITH_MAIN_FUNC
	sleep(1);
	len = sizeof(der);
	src = (unsigned char *)pem_enc;
	memset(der, 0, len);
	if (base64_decode(der, &len, src, 1284, 0) != 0 ||
	    memcmp(der, pem_dec, sizeof(pem_dec)) != 0) {
		if (verbose != 0) {
			printf("failed\n");
		}
	}
	for (i = 0; i < len; i++) {
		if (!(i%16)) {
			printf("\n");
		}
		printf("%02x ", der[i]);
	}

	printf("\n");
	sleep(1);
	src = (unsigned char *)pem_dec;
	len = sizeof(der);
	memset(der, 0, len);
	if (base64_encode(der, &len, src, sizeof(pem_dec), 0) != 0 ||
	    memcmp(der, pem_enc, len) != 0) {
		if (verbose != 0) {
			printf("failed\n");
		}
	}
	for (i = 0; i < len; i++) {
		if (!(i%64)) {
			printf("\n");
		}
		printf("%c", der[i]);
	}
	printf("\n");
#endif /* WITH_MAIN_FUNC */

	if (verbose != 0) {
		printf("passed\n\n");
	}

	return 0;
}

#ifdef WITH_MAIN_FUNC
int
main(int argc, char *argv[])
{
	base64_self_test(1);
}
#endif
#endif
